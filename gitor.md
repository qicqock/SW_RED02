#Git이란 무엇일까?

이 장은 Git에 대한 기본적인 내용을 정리해놓은 장이다.

버전 관리 도구란 무엇일까? Git은 어떻게 설치할까? Git은 어떻게 설정하고 사용할까?
Git은 어떻게 탄생했고, 사람들이 왜 이렇게 열광할까?

우선 **버전관리**가 무엇인지 알아보자.

----------
# 1. 버전 관리 시스템
----------

### 버전 관리 시스템 (VCS)이란?
`VCS(Version control System).
파일 변화를 시간에 따라 기록했다가 나중에 특정 시점의 버전을 다시 꺼내올수 있는 시스템.`

버전관리를 이용하는 것은 개발자에게 다음과 같은 이점이 있다.

- 시간에 따라 수정 내용을 알 수 있다.
- 누가, 언제, 어디서 오류를 냈는지 확인할 수 있다.
- 파일을 잃어버리거나, 잘못 고쳤을때도 쉽게 복구할 수 있다.


### 로컬 버전 관리 시스템

`: Local VCS. (Local Version Control System.)`


영희는 자소서(자기소개서)를 고쳐 쓰고 있었다. 영희는 어디를 어떻게 수정했는지 기록하고 싶었다. 그래서 영희는 수정본을 저장할 때 마다 파일이름을 달리해 알아보기 쉽도록 했다.
>
>
>-자소서1.docx
-자소서2.docx
-자소서아마도4.docx
.
.
-자소서_최종.docx
-자소서_진짜최종.docx
-자소서_이게진짜최종.docx
-자소서_대박이게진짜최종.docx
-자소서_정말이게진짜최종마지막.docx
-자소서_이름을길게하면최종인줄알겠지.docx

서로 다른 파일을 비교하면서 영희는 수정한 내용을 확인할 수 있다.
마음에 안들면 되돌릴 수 있고, 마음에 들었던 문장을 다시 가져올 수도있다.

*하지만 어디를 수정하고 저장한걸까? 실수로 삭제하면 어떻게 해야할까?*

이러한 방식은 알아보기 힘들고, 수정사항이 뚜렷하게 보이지 않고, 실수로 삭제하면 경우에 따라 복구하기도 힘들다.

코드의 경우도 그렇다. 이러한 이유로 프로그래머들은 **로컬 VCS**라는 것을 만들었다. 이 VCS는 아주 간단한 데이터 베이스를 사용해서 파일의 변경 정보를 관리한다.

##### + RCS

VCS도구중 많이쓰이는 RCS라는 것이 있다. 오늘날(1982~)까지도 많은 회사들이 사용하고 있는데, Mac OS에서는 개발 도구를 설치하면 함께 설치된다. 기본적으로 Patch set(파일에서 변경되는 부분)을 관리한다.

### 중앙집중식 버전관리
`: CVCS. (Central Version Control System.)`

개발을 하다보면 나 혼자 작업하는 것이아닌 다른 개발자와 함께 작업하는 경우가 많다. 이럴때는 로컬VCS로만 관리하기에는 한계가 있다. 이를 해결하기 위해 CVCS가 개발됐다. 이 시스템에는, 파일을 관리하는 서버가 별도로 있고 개발자들이 중앙 서버에서 파일을 받아서(Checkout) 사용한다.

CVCS 환경에서, 프로젝트의 개발자 모두 누가 무엇을 하는지 알수있고, 관리자는 누가 무엇을 할지 꼼꼼하게 관리할 수 있다. 로컬 VCS에 비해 분명한 장점이 있지만, 완벽한 것은 아니다.

<사진>

치명적인 결점중 대표적인 것은, **중앙 서버에 발생하는 문제이다.** 중앙 서버를 중심으로 돌아가는 시스템인 만큼 중앙 서버가 다운되면 아무것도 할 수 없게된다. 또 중앙 데이터베이스가 있는 하드디스크에 문제가 생기면 프로젝트의 모든 버전들이 날아간다. 로컬 VCS역시 이러한 문제점을 가지고 있다.

CVS, Subversion, Perforce 등이 CVCS에 해당하는데, 오픈소스계의 아이돌 리누스 토발즈가 Subversion을 사용하다 화딱지가 나 개발한 것이 다음으로 설명할 분산 버전 관리 시스템중 하나인 Git 이다.


### 분산 버전 관리 시스템
`: DVCS. (Distributed Version Control System. or Distributed Revision control)`

<사진>

DVCS환경에서 클라이언트는 단순히 파일의 마지막 스냅샷을 Checkout(받아와서 작업하는 것.)하지 않는다. 그냥 **저장소를 통채로 복제해온다.** CVCS는 중앙 데이터베이스를 잃으면 끝이지만, DVCS환경에서는 중앙 데이터베이스를 잃으면 클라이언트가 복제한 저장소를 바탕으로 서버를 복원할 수 있다. **진정한 백업인 것이다.**

Git(), Mecurial(2005), Bazzar(), Darcs() 등이 이 시스템에 해당하며 우리가 알아볼 것은 바로 **Git** 이다.


------
# 2. Git의 이해
------

### 1. Git의 시작
#### BitKeeper

1. 리누스 토발즈가 subversion을 쓰다가 빡쳐서.
2. BitKeeper 를 원래 사용했는데, 무료사용을 제제당하면서 리누스가 자체적으로 분산형 버전관리시스템을 개발해야했음.
2016년 오픈소스로 전환됨.

### 2. Git의 특징
깃은 데이터를 다루는데에 있어 기존의 VCS와는 다른 방식을 가진다. 기존의 VCS는 파일의 변경사항을 시간순으로 관리면서 파일들의 집합을 관리한다.
<그림1>

1. 네트워크에 대해 상대적으로 의존도가 낮음.
2. 스냅샷으로 저장하기 때문에

#### 스냅샷
#### 체크섬
#### SHA1
#### 해쉬
### 3. Git의 원릐


##정리중
http://openturorial.org/course/2708
을 참고하여 강의노트로 작성한 것임.


->gistory이용
깃을 이용했을때 내부적으로 어떤 일이 벌어지는지 알기위해 만들어진 프로그램.
GUI로 한눈에 확인가능!

1. 깃 애드를 했을때 어떤 변화가 있을까?
> git init을 하면
깃이라는 폴더가 생긴다
파일을 추가하면 깃은 아무런 관여를 하지않는다. 그래서  이때 add 를 통해 깃으로 관리하겠다고 선언해야한다. git add t1.txt 라고 저장하면,
index 파일과 objects폴더에 변화가 생긴다
이때는 제목이 주소?(해쉬?) 로 저장된다. objects에 들어가면 내용에 'a'라고 적힌 16진수제목의 파일(오브젝트,객체.)이있다. 이떄 파일제목은 안적혀있는데, index라는 파일안에 제목이 적혀져있다.
또다른 파일을 만들었다고 하자.
f2.txt 에 'z' 를 저장하면, 인덱스에 f2가 추가 되어있고, objects 폴더안에 그내용이 저장되어있다.
그럼 f1를 f3로 복사하면?
f1.txt의 내용을 저장한 객체와 인덱스만 변화 한다. 인덱스를보면, f3를 보면 같은 주소, 오브젝트를 가리키고 있음을 알 수 있다.
깃은 파일을 저장할때 파일의 이름이 달라도 내용이 같으면 같은 오브젝트파일을 가리킨다는 것.
이때, 내용이 같으면 제목이 같을 것이다. 가령 내용이 'a'라면.. 78디렉토리에 98로 시작하는 오브젝트 파일이 생성된다.
(+ 오브젝트 파일)
SHA-1을 통해 만들어진 체크섬. 경로는 40자길이의 16진수로 만들어 진다. 앞의 두자리는 오브젝트 디렉토리의 새로운 폴더명이되며, 마지막 38자리는 파일명이 된다.
해쉬값의 이름을 가진 파일의 내용은 애드시킨 파일의 내용이 담기게 된다.
인덱스 파일은 변경된 파일명과 함꼐 해쉬파일을 참조한다.
새로운 파일을 추가하면 마찬가지로 인덱스파일에 새로운 버전을 가진 해쉬태그를 참조하는 파일명이 새롭게 생신이 되며 , 오브젝트 폴더에 애드한 파일이 해쉬값의 파일명으로 저장된다.
이때 똑같은 파일을 만들고 애드하면 오브젝트 폴더에 새로운 파일이 추가되지 않는다. 해쉬변환기로 돌린 파일이 오브젝트 폴더에 이미 존재하면 똑같은 파일을 새로 만들지 않고 해당 파일을 참조하게 된다. 이로써 깃은 기존의 버전관리 시스템과는 다르게 아주 효율적인 구조를 가지고 있다고 볼 수 있다. 데이터를 스냅샷으로 취급하기 때문에 중복될 일이 없고, 리눅스 커널과 같은 대형프로젝트에 도입하면 그 장점을 톡톡히 살릴 수 있다.

2. 오브젝트 파일명의 원리
> sha1 = 해쉬 알고리즘. 여길 통과해서 앞 두글자를 디렉토리명으로 만들고 38자로 오브젝트 파일명을 정하는 것이다.
깃은 수많은 버전들을 파일명, 만들어진 날짜순을 보관하는게 아니라 샤-1 이라고 부르는 특정 해쉬 알고리즘을 통과한 값을 기준으로 저장하기 때문이다.
샤-1 , 해쉬 등등 부가적인 자료 추가 예정.

3. commit의 원리.
> objects디렉토리의 변화.  파일을 커밋(버전을 만드는작업)하면 하나의 객체로 저장된다. 커밋안에는 '누가 작성했는지, 커밋메시지, tree 라고하는 것과 오브젝트가 해쉬의 형태로 링크되어있다 ' 가 저장되어 있다. 이때 이 해쉬로 들어가보면 f1,f2가 무엇인지 적혀있는 정보.
parent - 이전 파일.

>+)정리
>커밋에는 중요한 정보가 두가지 있다. 1. 이전 커밋, 부모가 무엇인가? 2. 커밋이 일어난 시점 이다.
커밋이 일어난 시점애 작업디렉토리.......혼란하다 혼란해

>다시 정리.
버전이 만들어진 시점의 파일들이 트리로 담겨져 있음.


>+2)구글링. github.com/k2amj2ik/Lecture
모든기록은 .git/에 .
repository를 구성하고 있는 object : blob, tree, pointer.
<<이미지>>
커밋 : 작성자, 커밋메시지 (-m "",또는 vim으로 작성한.) 트리.
트리 : 블랍
블랍 : 라이선스. 파일의 내용을 담는대

>+2)구글링. programmingfbf7290.tistory.com
여긴 생코처럼 기스토리로 정리해놨음.
커밋을 하면 커밋에 관련된 정보가 object파일로 저장된다. 커밋관련정보 : 메시지,작성자,tree"오브젝트 링크".
tree는 해당 버전에 관련된 파일정보들을 가지는 파일이다. 오브젝트 링크를 누르면 해당버전에 f1~f3.txt가 있는것을볼수있다.(왜??), 또 각각의 파일에 대한 객체파일의 위치가 나온다.(해쉬)
여기서 추가적인 커밋을 할경우에, 오브젝트 파일에 트리, parent, 작성자 정보, 메시지가 담기는 것을 알수 있다. 이때 패런트는 이전 커밋 오브젝트 파일과 연결되어 있다.(커밋에서 트리, 패런트가 있고 각각의 버전은 버전이 만들어진 시점을 스냅샷해 트리라는 정보 구조안에 저장, 과거 버전의 파일을 참조할 수 있는것.)


#### Git의 세가지 상태
1. modified
2. staged
3. commited

<사진만들기>

------
# 3. 깃의 사용
------
기본적인 용어, 사용법.
------
# 4. 깃의 활용
------
왜 깃을써야하는지?
