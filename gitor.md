#Git이란 무엇일까?

이 장은 Git에 대한 기본적인 내용을 정리해놓은 장이다.

버전 관리 도구란 무엇일까? Git은 어떻게 설치할까? Git은 어떻게 설정하고 사용할까?
Git은 어떻게 탄생했고, 사람들이 왜 이렇게 열광할까?

우선 **버전관리**가 무엇인지 알아보자.

----------
# 1. 버전 관리 시스템
----------

## 버전 관리 시스템 (VCS)
`VCS(Version control System).
파일 변화를 시간에 따라 기록했다가 나중에 특정 시점의 버전을 다시 꺼내올수 있는 시스템.`

버전관리를 이용하는 것은 개발자에게 다음과 같은 이점이 있다.

- 시간에 따라 수정 내용을 알 수 있다.
- 누가, 언제, 어디서 오류를 냈는지 확인할 수 있다.
- 파일을 잃어버리거나, 잘못 고쳤을때도 쉽게 복구할 수 있다.


#### 로컬 버전 관리 시스템

`: Local VCS. (Local Version Control System.)`


영희는 자소서(자기소개서)를 고쳐 쓰고 있었다. 영희는 어디를 어떻게 수정했는지 기록하고 싶었다. 그래서 영희는 수정본을 저장할 때 마다 파일이름을 달리해 알아보기 쉽도록 했다.
>
>
>-자소서1.docx
-자소서2.docx
-자소서아마도4.docx
.
.
-자소서(최종).docx
-자소서(진짜최종).docx
-자소서(이게진짜최종).docx
-자소서(대박이게진짜최종).docx
-자소서(정말이게진짜최종마지막).docx
-자소서(이름을길게하면최종인줄알겠지).docx

서로 다른 파일을 비교하면서 영희는 수정한 내용을 확인할 수 있다.
마음에 안들면 되돌릴 수 있고, 마음에 들었던 문장을 다시 가져올 수도있다.

*하지만 어디를 수정하고 저장한걸까? 실수로 삭제하면 어떻게 해야할까?*

이러한 방식은 알아보기 힘들고, 수정사항이 뚜렷하게 보이지 않고, 실수로 삭제하면 경우에 따라 복구하기도 힘들다.

코드의 경우도 그렇다. 이러한 이유로 프로그래머들은 **로컬 VCS**라는 것을 만들었다. 이 VCS는 아주 간단한 데이터 베이스를 사용해서 파일의 변경 정보를 관리한다.

###### + RCS

VCS도구중 많이쓰이는 RCS라는 것이 있다. 오늘날(1982~)까지도 많은 회사들이 사용하고 있는데, Mac OS에서는 개발 도구를 설치하면 함께 설치된다. 기본적으로 Patch set(파일에서 변경되는 부분)을 관리한다.

#### 중앙집중식 버전관리
`: CVCS. (Central Version Control System.)`

개발을 하다보면 나 혼자 작업하는 것이아닌 다른 개발자와 함께 작업하는 경우가 많다. 이럴때는 로컬VCS로만 관리하기에는 한계가 있다. 이를 해결하기 위해 CVCS가 개발됐다. 이 시스템에는, 파일을 관리하는 서버가 별도로 있고 개발자들이 중앙 서버에서 파일을 받아서(Checkout) 사용한다.

CVCS 환경에서, 프로젝트의 개발자 모두 누가 무엇을 하는지 알수있고, 관리자는 누가 무엇을 할지 꼼꼼하게 관리할 수 있다. 로컬 VCS에 비해 분명한 장점이 있지만, 완벽한 것은 아니다.

<사진>

치명적인 결점중 대표적인 것은, **중앙 서버에 발생하는 문제이다.** 중앙 서버를 중심으로 돌아가는 시스템인 만큼 중앙 서버가 다운되면 아무것도 할 수 없게된다. 또 중앙 데이터베이스가 있는 하드디스크에 문제가 생기면 프로젝트의 모든 버전들이 날아간다. 로컬 VCS역시 이러한 문제점을 가지고 있다.

CVS, Subversion, Perforce 등이 CVCS에 해당하는데, 오픈소스계의 아이돌 리누스 토발즈가 Subversion을 사용하다 화딱지가 나 개발한 것이 다음으로 설명할 분산 버전 관리 시스템중 하나인 Git 이다.


#### 분산 버전 관리 시스템
`: DVCS. (Distributed Version Control System. or Distributed Revision control)`

<사진>

DVCS환경에서 클라이언트(공동 개발자)는 단순히 파일의 마지막 스냅샷을 Checkout(받아와서 작업하는 것.)하지 않는다. 그냥 **저장소를 그대로 복제해온다.** CVCS는 중앙 데이터베이스를 잃으면 끝이지만, DVCS환경에서는 중앙 데이터베이스를 잃으면 클라이언트가 복제한 저장소를 바탕으로 서버를 복원할 수 있다. **진정한 백업인 것이다.**

Git(), Mecurial(2005), Bazzar(), Darcs() 등이 이 시스템에 해당하며 우리가 알아볼 것은 바로 **Git** 이다.


------
# 2. Git의 이해
------

## Git의 시작

Git의 탄생은 리눅스 커널(Linux Kernel)개발 현장에서부터 시작한다.
과거 이 프로젝트는 상용 분산 버전관리 프로그램인 비트키퍼의 커뮤니티(Community)버전을 무료로 공급받아 진행되고 있었다. 그러나 불법적인 Reverse Engineering이 세 차례 이어지면서 비트키퍼측은 커뮤니티 버전의 배포를 중단하고, 이로인해 리누스가 독자적인 프로그램을 개발하여 탄생한 것이 바로 **Git**이다.

###### + BitKeeper
당시 사유 소프트웨어(Proprietary Software,독점 소프트웨어)였으나 2016년 5월을 기준으로 Apache License 아래의 오픈소스 프로그램이 되었다.

###### + Reverse Engineering
리버스 엔지니어링(영어: reverse engineering, RE) 또는 역공학(逆工學)은 장치 또는 시스템의 기술적인 원리를 그 구조분석을 통해 발견하는 과정. 종종 대상(기계 장치, 전자 부품, 소프트웨어 프로그램 등)을 조각내서 분석하는 것을 포함한다. 그리고 유지 보수를 위해, 또는 같은 기능을 하는 새 장치를 원본의 일부를 이용하지 않고 만들기 위해 대상의 세부적인 작동을 분석하는 것을 포함한다.

###### + 상용 프로그램
상용 소프트웨어(Commercial Software)에서 독점 소프트웨어(Proprietary Software) 와 무료 및 오픈소스 소프트웨어(Free and OpenSource Software)

## Git의 특징
깃은 데이터를 다루는데에 있어 기존의 VCS와는 다른 방식을 가진다. 기존의 VCS는 파일의 변경사항을 시간순으로 관리면서 파일들의 집합을 관리한다.
<그림1>

1. 네트워크에 대해 상대적으로 의존도가 낮음.
2. 스냅샷으로 저장하기 때문에

##### 스냅샷

##### 체크섬(Checksum)
##### SHA1
##### 해쉬

## Git의 원릐


#### 정리중
http://openturorial.org/course/2708
을 참고하여 강의노트로 작성한 것임.


->gistory이용
깃을 이용했을때 내부적으로 어떤 일이 벌어지는지 알기위해 만들어진 프로그램.
GUI로 한눈에 확인가능!

### 1. 깃 애드를 했을때 어떤 변화가 있을까?
> git init을 하면
깃이라는 폴더가 생긴다
파일을 추가하면 깃은 아무런 관여를 하지않는다. 그래서  이때 add 를 통해 깃으로 관리하겠다고 선언해야한다. git add t1.txt 라고 저장하면,
index 파일과 objects폴더에 변화가 생긴다
이때는 제목이 주소?(해쉬?) 로 저장된다. objects에 들어가면 내용에 'a'라고 적힌 16진수제목의 파일(오브젝트,객체.)이있다. 이떄 파일제목은 안적혀있는데, index라는 파일안에 제목이 적혀져있다.
또다른 파일을 만들었다고 하자.
f2.txt 에 'z' 를 저장하면, 인덱스에 f2가 추가 되어있고, objects 폴더안에 그내용이 저장되어있다.
그럼 f1를 f3로 복사하면?
f1.txt의 내용을 저장한 객체와 인덱스만 변화 한다. 인덱스를보면, f3를 보면 같은 주소, 오브젝트를 가리키고 있음을 알 수 있다.
깃은 파일을 저장할때 파일의 이름이 달라도 내용이 같으면 같은 오브젝트파일을 가리킨다는 것.
이때, 내용이 같으면 제목이 같을 것이다. 가령 내용이 'a'라면.. 78디렉토리에 98로 시작하는 오브젝트 파일이 생성된다.
(+ 오브젝트 파일)
SHA-1을 통해 만들어진 체크섬. 경로는 40자길이의 16진수로 만들어 진다. 앞의 두자리는 오브젝트 디렉토리의 새로운 폴더명이되며, 마지막 38자리는 파일명이 된다.
해쉬값의 이름을 가진 파일의 내용은 애드시킨 파일의 내용이 담기게 된다.
인덱스 파일은 변경된 파일명과 함꼐 해쉬파일을 참조한다.
새로운 파일을 추가하면 마찬가지로 인덱스파일에 새로운 버전을 가진 해쉬태그를 참조하는 파일명이 새롭게 생신이 되며 , 오브젝트 폴더에 애드한 파일이 해쉬값의 파일명으로 저장된다.
이때 똑같은 파일을 만들고 애드하면 오브젝트 폴더에 새로운 파일이 추가되지 않는다. 해쉬변환기로 돌린 파일이 오브젝트 폴더에 이미 존재하면 똑같은 파일을 새로 만들지 않고 해당 파일을 참조하게 된다. 이로써 깃은 기존의 버전관리 시스템과는 다르게 아주 효율적인 구조를 가지고 있다고 볼 수 있다. 데이터를 스냅샷으로 취급하기 때문에 중복될 일이 없고, 리눅스 커널과 같은 대형프로젝트에 도입하면 그 장점을 톡톡히 살릴 수 있다.

### 2. 오브젝트 파일명의 원리
> sha1 = 해쉬 알고리즘. 여길 통과해서 앞 두글자를 디렉토리명으로 만들고 38자로 오브젝트 파일명을 정하는 것이다.
깃은 수많은 버전들을 파일명, 만들어진 날짜순을 보관하는게 아니라 샤-1 이라고 부르는 특정 해쉬 알고리즘을 통과한 값을 기준으로 저장하기 때문이다.
샤-1 , 해쉬 등등 부가적인 자료 추가 예정.

### 3. commit의 원리.
> objects디렉토리의 변화.  파일을 커밋(버전을 만드는작업)하면 하나의 객체로 저장된다. 커밋안에는 '누가 작성했는지, 커밋메시지, tree 라고하는 것과 오브젝트가 해쉬의 형태로 링크되어있다 ' 가 저장되어 있다. 이때 이 해쉬로 들어가보면 f1,f2가 무엇인지 적혀있는 정보.
parent - 이전 파일.

>+)정리
>커밋에는 중요한 정보가 두가지 있다. 1. 이전 커밋, 부모가 무엇인가? 2. 커밋이 일어난 시점 이다.
커밋이 일어난 시점애 작업디렉토리.......혼란하다 혼란해

>다시 정리.
버전이 만들어진 시점의 파일들이 트리로 담겨져 있음.


>+2)구글링. github.com/k2amj2ik/Lecture
모든기록은 .git/에 .
repository를 구성하고 있는 object : blob, tree, pointer.
<<이미지>>
커밋 : 작성자, 커밋메시지 (-m "",또는 vim으로 작성한.) 트리.
트리 : 블랍
블랍 : 라이선스. 파일의 내용을 담는대
스냅샷=트리 이런거임 ㅋㅋㅋㅋ ㅇ라ㅓㅇ황호어ㅏㄴ온러ㅗㅁ엏

>+2)구글링. programmingfbf7290.tistory.com
여긴 생코처럼 기스토리로 정리해놨음.
커밋을 하면 커밋에 관련된 정보가 object파일로 저장된다. 커밋관련정보 : 메시지,작성자,tree"오브젝트 링크".
tree는 해당 버전에 관련된 파일정보들을 가지는 파일이다. 오브젝트 링크를 누르면 해당버전에 f1~f3.txt가 있는것을볼수있다.(왜??), 또 각각의 파일에 대한 객체파일의 위치가 나온다.(해쉬)
여기서 추가적인 커밋을 할경우에, 오브젝트 파일에 트리, parent, 작성자 정보, 메시지가 담기는 것을 알수 있다. 이때 패런트는 이전 커밋 오브젝트 파일과 연결되어 있다.(커밋에서 트리, 패런트가 있고 각각의 버전은 버전이 만들어진 시점을 스냅샷해 트리라는 정보 구조안에 저장, 과거 버전의 파일을 참조할 수 있는것.)

### 4. status의 원리 <내용 넣을수도 있고 뺄 수도 있음.>
 >index가 무엇인가?

#### Git의 세가지 상태
1. modified
2. staged
3. commited

<사진만들기>

------
# 3. Git 시작하기
------
## 기본적인 용어정리
기본적으로 알아야 할 용어만을 정리해 두었다. 자세한 내용은 스스로 Git을 공부하며 알아가자.

> - Commit
: 파일의 변경 사항을 저장하는 객체의 일종. 작성자, Commit Message, Tree, 커밋이 만들어진 시점등이 저장되어 있다. Commit을 진행할 때 마다 새로운 객체를 만든다.

> - Commit Message
: 어떤 변경사항이 있는지
‘ -m "(message)" ’ 기능을 활용해 왜 변경했는지에 대한 이유를 작성한다. (이에 관한 내용 뒤에서 서술)
 
> - Branch
테스트를 해보거나 새로운 기능을 개발하기 위해 사용할 수 있는 따로 떨어진 독립적인 commit들을 말한다.
 
> - master branch
새로운 Git 프로젝트를 만들 때마다 ‘master’라고 불리는 기분 브랜치가 생성된다.
배포가 준비가 되면 작업이 최종적으로 마무리된다. -> ex) 마스터로 바로 commit 하지말자!
 
> - merge
병합은 한 branch에서 완성된 작업을 가져와 다른 branch에 포함하는 방법이다.
흔히 기타 브랜치를 master branch로 merge 한다.
 
> - checkout
프로젝트 히스토리의 다른 버전으로 이동해 해당 시점의 파일을 보기위한 것.
일반적으로 branch에서 완료된 작업을 모두 보기위해 branch를 check out하지만 commit도 check out할 수 있다.
 
> - pull request
각각의 branch에서 완료된 작업을 master로 merge요청을 하기 위해 사용.
 
> - issue
기능 논의, 버그 추적시에 사용
 
> - wiki
링크들을 연결해 간단하게 웹페이지를 만드는 방법이다.
 
> - clone 
로컬로 작업하기 위해 프로젝트 복사본을 github에서 다운로드 받는 것.
repository를 사용자의 컴퓨터로 복사하는 것이다.
 
> - Fork
프로젝트에 참가하기 위해서는 프로젝트의 복사본을 만들어야 한다.
그 과장을 repository를 fork한다고 한다. fork하고, clone하고, modify하고, pull request를 이용해 원본 프로젝트에 반영할 수 있다.

## Git 시작하기

------
# 마치며
------
왜 깃을써야하는지?
